#version 450

uniform int dynamicMatrixSize;
uniform int place;

const int MATRIX_SIZE = 1024;
const int THREADS_COUNT = min(1024, MATRIX_SIZE / 2);

shared vec4 buff[THREADS_COUNT];
shared vec4 buff2[THREADS_COUNT];

layout(std430, binding = 2) buffer layoutName3
{
    uint quadsInMatrix[];
};

struct material
{
    vec4 color;
    vec4 emission;
};

layout(std430, binding = 3) buffer layoutName4
{
    material mats[];
};

layout(std430, binding = 4) buffer layoutName7
{
    int usedQuads[];
};

layout(std430, binding = 5) buffer layoutName8
{
    vec4 fRow[];
};

layout(std430, binding = 6) buffer layoutName9
{
    vec4 fColumn[];
};

layout(std430, binding = 7) buffer layoutName10
{
    vec4 doubleReflection;
};

layout(std430, binding = 8) buffer layoutName11
{
    vec4 gRow[];
};

layout(std430, binding = 9) buffer layoutName12
{
    vec4 gColumn[];
};

layout(std430, binding = 10) buffer layoutName13
{
    vec4 localColors[];
};


layout(local_size_x = THREADS_COUNT) in;
layout(location = 0, rgba16f) uniform image2D localMatrixTex;
void main() {
    uint trIdx = gl_LocalInvocationID.x;
    uint columnIdx = gl_WorkGroupID.x;

    vec4 b1_sum = vec4(0);
    vec4 b2_sum = vec4(0);

    for (int iter = 0; iter < MATRIX_SIZE / THREADS_COUNT / 2; ++iter) {
        vec4 color1 = localColors[trIdx + iter * THREADS_COUNT];
        vec4 g_column1 = gColumn[trIdx + iter * THREADS_COUNT];
        vec4 g_row1 = gRow[trIdx + iter * THREADS_COUNT];
        uint isUsed1 = usedQuads[trIdx + iter * THREADS_COUNT];
        vec4 color2 = localColors[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2];
        vec4 g_column2 = gColumn[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2];
        vec4 g_row2 = gRow[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2];
        uint isUsed2 = usedQuads[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2];

        imageStore(localMatrixTex, ivec2(place, trIdx + iter * THREADS_COUNT), g_row1);
        imageStore(localMatrixTex, ivec2(trIdx + iter * THREADS_COUNT, place), g_column1);
        imageStore(localMatrixTex, ivec2(place, trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2), g_row2);
        imageStore(localMatrixTex, ivec2(trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2, place), g_column2);

        buff[trIdx] = g_row1 * color1 + g_row2 * color2;
        buff2[trIdx] = (isUsed1 != 0 ? vec4(0) : g_column1) + (isUsed2 != 0 ? vec4(0) : g_column2);
        memoryBarrierShared();
        barrier();

        for (int i = MATRIX_SIZE / 4; i > 32; i >>= 1) {
            if (trIdx < i) {
                buff[trIdx] += buff[i + trIdx];
                buff2[trIdx] += buff2[i + trIdx];
            }
            memoryBarrierShared();
            barrier();
        }

        for (int i = 32; i > 0; i >>= 1) {
            if (trIdx < i) {
                buff[trIdx] += buff[i + trIdx];
                buff2[trIdx] += buff2[i + trIdx];
            }
        }

        if (trIdx == 0) {
            b1_sum += buff[0];
            b2_sum += buff2[0];
        }

        memoryBarrierShared();
        barrier();
    }

    if (gl_GlobalInvocationID.x == 0) {
        imageStore(localMatrixTex, ivec2(place, place), b1_sum * b2_sum);
    }
}
