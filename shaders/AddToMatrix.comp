#version 450

uniform int dynamicMatrixSize;
uniform int place;

const int MATRIX_SIZE = 1024;

shared vec4 buff[MATRIX_SIZE];
shared vec4 buff2[MATRIX_SIZE];

layout(std430, binding = 2) buffer layoutName3
{
    uint quadsInMatrix[];
};

struct material
{
    vec4 color;
    vec4 emission;
};

layout(std430, binding = 3) buffer layoutName4
{
    material mats[];
};

layout(std430, binding = 4) buffer layoutName7
{
    int usedQuads[];
};

layout(std430, binding = 5) buffer layoutName8
{
    vec4 fRow[];
};

layout(std430, binding = 6) buffer layoutName9
{
    vec4 fColumn[];
};


layout(local_size_x = MATRIX_SIZE, local_size_y = 1) in;
layout(location = 0, rgba16f) uniform image2D localMatrixTex;
void main() {
    uint trIdx = gl_GlobalInvocationID.x;

    uint idx = quadsInMatrix[trIdx];
    vec4 f_column = fColumn[trIdx];
    vec4 f_row = fRow[trIdx];
    vec4 color = mats[idx].color;
    vec4 g_column = fColumn[trIdx];
    vec4 g_row = fRow[trIdx];
    vec4 placeColor = mats[quadsInMatrix[place]].color;

//    imageStore(localMatrixTex, ivec2(place, trIdx), vec4(0, 0, 0, 0));
//    imageStore(localMatrixTex, ivec2(trIdx, place), vec4(0, 0, 0, 0));

    buff[trIdx] = f_column * f_row * color;
    memoryBarrierShared();
    barrier();

    for (int i = MATRIX_SIZE / 2; i > 0; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
        }
        memoryBarrierShared();
        barrier();
    }

    vec4 double_reflection = buff[0] * placeColor;

    memoryBarrierShared();
    barrier();

    g_column += f_column * double_reflection;
    g_row += f_row * double_reflection;

    buff[trIdx] = f_column * color;
    memoryBarrierShared();
    barrier();

    for (int i = 0; i < MATRIX_SIZE; ++i) {
        g_column += imageLoad(localMatrixTex, ivec2(trIdx, i)) * buff[i];
    }
    memoryBarrierShared();
    barrier();

    buff[trIdx] = f_row * color;
    memoryBarrierShared();
    barrier();

    for (int i = 0; i < MATRIX_SIZE; ++i) {
        g_row += imageLoad(localMatrixTex, ivec2(i, trIdx)) * buff[i];
    }
    memoryBarrierShared();
    barrier();

    buff[trIdx] = usedQuads[trIdx] == 0 ? g_column * placeColor : vec4(0);

    memoryBarrierShared();
    barrier();

    for (int i = 0; i < MATRIX_SIZE; ++i) {
        imageStore(localMatrixTex, ivec2(i, trIdx), imageLoad(localMatrixTex, ivec2(i, trIdx)) + buff[i] * g_row);
    }

    memoryBarrierShared();
    barrier();

    buff[trIdx] = g_row * color;
    buff2[trIdx] = (usedQuads[trIdx] != 0) ? vec4(0) : g_column;

    imageStore(localMatrixTex, ivec2(place, trIdx), g_row);
    imageStore(localMatrixTex, ivec2(trIdx, place), g_column);

    memoryBarrierShared();
    barrier();

    for (int i = MATRIX_SIZE / 2; i > 0; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
            buff2[trIdx] += buff2[i + trIdx];
        }
        memoryBarrierShared();
        barrier();
    }

    if (trIdx == 0) {
        imageStore(localMatrixTex, ivec2(place, place), buff[0] * buff2[0]);
    }
}
