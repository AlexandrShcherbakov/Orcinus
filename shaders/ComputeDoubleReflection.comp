#version 450

uniform int place;

const int MATRIX_SIZE = MATRIX_SIZE_VALUE;
const int THREADS_COUNT = min(1024, MATRIX_SIZE / 2);

shared vec3 buff[THREADS_COUNT];

layout(std430, binding = 2) buffer layoutName3
{
    uint quadsInMatrix[];
};

struct material
{
    vec4 color;
    vec4 emission;
};

layout(std430, binding = 3) buffer layoutName4
{
    material mats[];
};

layout(std430, binding = 4) buffer layoutName7
{
    int usedQuads[];
};

layout(std430, binding = 5) buffer layoutName8
{
    float fRow[];
};

layout(std430, binding = 6) buffer layoutName9
{
    float fColumn[];
};

layout(std430, binding = 7) buffer layoutName10
{
    vec4 doubleReflection[];
};

layout(std430, binding = 10) buffer layoutName13
{
    vec4 localColors[];
};

layout(std430, binding = 11) buffer layoutName14
{
    vec4 localEmission[];
};

layout(local_size_x = THREADS_COUNT) in;
void main() {
    uint trIdx = gl_LocalInvocationID.x;

    uint idx = quadsInMatrix[gl_GlobalInvocationID.x];
    vec3 placeColor = mats[quadsInMatrix[place]].color.rgb;

    vec3 colorFirst = mats[idx].color.rgb;
    vec3 colorSecond =  mats[quadsInMatrix[gl_GlobalInvocationID.x + MATRIX_SIZE / 2]].color.rgb;
    localColors[gl_GlobalInvocationID.x] = vec4(colorFirst, 0);
    localColors[gl_GlobalInvocationID.x + MATRIX_SIZE / 2] = vec4(colorSecond, 0);

    localEmission[gl_GlobalInvocationID.x] = mats[quadsInMatrix[gl_LocalInvocationID.x]].emission;
    localEmission[gl_GlobalInvocationID.x + MATRIX_SIZE / 2] = mats[quadsInMatrix[gl_LocalInvocationID.x + MATRIX_SIZE / 2]].emission;

    buff[trIdx] = fColumn[gl_GlobalInvocationID.x] * fRow[gl_GlobalInvocationID.x] * colorFirst
        + fColumn[gl_GlobalInvocationID.x + MATRIX_SIZE / 2] * fRow[gl_GlobalInvocationID.x + MATRIX_SIZE / 2] * colorSecond;
    memoryBarrierShared();
    barrier();

    for (int i = MATRIX_SIZE / 4; i > 32; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
        }
        memoryBarrierShared();
        barrier();
    }

    for (int i = 32; i > 0; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
        }
    }

    if (trIdx == 0) {
        doubleReflection[gl_GlobalInvocationID.x / THREADS_COUNT] = vec4(buff[0] * placeColor, 0);
    }
}
