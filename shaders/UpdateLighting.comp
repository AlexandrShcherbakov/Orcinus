#version 450

uniform int dynamicMatrixSize;

const int THREADS_COUNT = 512;

const int MATRIX_SIZE = 1024;
shared vec4 buff[THREADS_COUNT];

layout(std430, binding = 0) buffer layoutName1
{
    vec4 indirect_light[];
};

layout(std430, binding = 2) buffer layoutName3
{
    uint quadsInMatrix[];
};

struct material
{
    vec4 color;
    vec4 emission;
};

layout(std430, binding = 3) buffer layoutName4
{
    material mats[];
};

layout(local_size_x = THREADS_COUNT) in;
layout (location = 0, rgba16f) uniform image2D localMatrixTex;
void main() {
//    uint globalIdx = quadsInMatrix[gl_GlobalInvocationID.x];
//    vec4 lighting = vec4(0, 0, 0, 0);
//    for (int i = 0; i < MATRIX_SIZE; ++i) {
//        lighting += mats[quadsInMatrix[i]].emission * imageLoad(localMatrixTex, ivec2(gl_GlobalInvocationID.x, i));
//    }
//    indirect_light[globalIdx] = lighting + mats[globalIdx].emission;

    uint trIdx = gl_LocalInvocationID.x;
    uint rowIdx = gl_WorkGroupID.x;

    buff[trIdx] = mats[quadsInMatrix[trIdx]].emission *  imageLoad(localMatrixTex, ivec2(rowIdx, trIdx))
        + mats[quadsInMatrix[trIdx + MATRIX_SIZE / 2]].emission *  imageLoad(localMatrixTex, ivec2(rowIdx, trIdx + MATRIX_SIZE / 2));
    memoryBarrierShared();
    barrier();

    for (int i = MATRIX_SIZE / 4; i > 32; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
        }
        memoryBarrierShared();
        barrier();
    }

    for (int i = 32; i > 0; i >>= 1) {
        if (trIdx < i) {
            buff[trIdx] += buff[i + trIdx];
        }
    }

    if (trIdx == 0) {
        indirect_light[quadsInMatrix[rowIdx]] = buff[0] + mats[quadsInMatrix[rowIdx]].emission;
    }
}
