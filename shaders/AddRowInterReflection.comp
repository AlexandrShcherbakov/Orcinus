#version 450

const int MATRIX_SIZE = MATRIX_SIZE_VALUE;
const int THREADS_COUNT = min(1024, MATRIX_SIZE / 2);

shared vec3 buff[THREADS_COUNT];

layout(std430, binding = 5) buffer layoutName9
{
    float fRow[];
};

layout(std430, binding = 8) buffer layoutName12
{
    vec3 gRow[];
};

layout(std430, binding = 10) buffer layoutName13
{
    vec3 localColors[];
};


layout(local_size_x = THREADS_COUNT) in;
layout(location = 0, rgba16f) uniform image2D localMatrixTex;
void main() {
    uint trIdx = gl_LocalInvocationID.x;
    uint columnIdx = gl_WorkGroupID.x;

    vec3 result = vec3(0);

    for (int iter = 0; iter < MATRIX_SIZE / THREADS_COUNT / 2; ++iter) {
        buff[trIdx] = fRow[trIdx + iter * THREADS_COUNT] * localColors[trIdx + iter * THREADS_COUNT] * imageLoad(localMatrixTex, ivec2(trIdx + iter * THREADS_COUNT, columnIdx)).rgb
        + fRow[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2] * localColors[trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2] * imageLoad(localMatrixTex, ivec2(trIdx + iter * THREADS_COUNT + MATRIX_SIZE / 2, columnIdx)).rgb;
        memoryBarrierShared();
        barrier();

        for (int i = MATRIX_SIZE / 4; i > 32; i >>= 1) {
            if (trIdx < i) {
                buff[trIdx] += buff[i + trIdx];
            }
            memoryBarrierShared();
            barrier();
        }

        for (int i = 32; i > 0; i >>= 1) {
            if (trIdx < i) {
                buff[trIdx] += buff[i + trIdx];
            }
        }

        if (trIdx == 0) {
            result += buff[0];
        }
    }

    if (trIdx == 0) {
        gRow[columnIdx] += result;
    }
}
